{% extends 'base.html' %}

{% block title %}<span id="page-title">故障诊断</span> - <span id="platform-title">光伏数字孪生平台</span>{% endblock %}

{% block content %}
<div class="row mb-3">
    <div class="col-md-12">
        <div class="d-flex justify-content-between align-items-center">
            <h2 id="fault-diagnosis-header">故障诊断</h2>
            <div>
                <div class="form-check form-switch d-inline-block me-3">
                    <input class="form-check-input" type="checkbox" id="real-time-update" checked>
                    <label class="form-check-label" for="real-time-update" id="realtime-label">实时更新</label>
                </div>
                <button id="manual-refresh" class="btn btn-primary btn-sm">
                    <i class="bi bi-arrow-clockwise"></i> <span id="manual-refresh-text">手动刷新</span>
                </button>
                <div id="update-status" class="text-muted small mt-1">
                    <span id="last-update-time">正在加载...</span>
                    <span id="update-indicator" class="ms-2 d-none">
                        <i class="bi bi-arrow-repeat"></i> <span id="updating-text">更新中...</span>
                    </span>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="row">
    <div class="col-md-12">
        <div class="card mb-4">
            <div class="card-header" id="diagnosis-results">故障诊断结果</div>
            <div class="card-body">
                <h5 id="detected-anomalies">检测到的异常:</h5>
                <ul id="fault-causes-list">
                    {% for cause in fault_causes %}
                    <li>{{ cause.type }} - <span id="severity-text">严重程度</span>: {{ cause.severity|floatformat:2 }} ({{ cause.timestamp }})</li>
                    {% empty %}
                    <li id="no-anomalies">目前无自动检测到的异常</li>
                    {% endfor %}
                </ul>
                <h5 id="recommendations">建议措施:</h5>
                <ul id="recommendations-list">
                    <li id="check-charts-text">请检查下方图表分析具体情况。</li>
                    <li id="onsite-check-text">对于持续性异常，考虑安排现场检查。</li>
                </ul>
            </div>
        </div>
    </div>
</div>

<!-- 故障注入设置表单 -->
<div class="row">
    <div class="col-md-12">
        <div class="card mb-4">
            <div class="card-header" id="schedule-fault-header">为下一天仿真设置计划故障</div>
            <div class="card-body">
                <form id="schedule-fault-form">
                    {% csrf_token %}
                    <div class="row">
                        <div class="col-md-3 mb-3">
                            <label for="fault-type" class="form-label" id="fault-type-label">故障类型</label>
                            <select class="form-select" id="fault-type" name="fault_type">
                                <option value="PARTIAL_SHADING" id="partial-shading-option">部分阴影遮挡</option>
                                <option value="HOTSPOT" id="hotspot-option">组件热斑</option>
                                <option value="AGING_DEGRADATION" id="aging-option">组件老化衰减</option>
                                <option value="INVERTER_EFFICIENCY_DROP" id="inverter-option">逆变器效率下降</option>
                            </select>
                        </div>
                        <div class="col-md-2 mb-3">
                            <label for="fault-start-hour" class="form-label" id="start-hour-label">开始时间 (小时)</label>
                            <input type="number" class="form-control" id="fault-start-hour" name="start_hour" min="0"
                                max="23" value="8">
                        </div>
                        <div class="col-md-2 mb-3">
                            <label for="fault-end-hour" class="form-label" id="end-hour-label">结束时间 (小时)</label>
                            <input type="number" class="form-control" id="fault-end-hour" name="end_hour" min="0"
                                max="23" value="10">
                        </div>
                        <div class="col-md-3 mb-3">
                            <label for="fault-severity" class="form-label" id="severity-label">严重程度 (0.1-1.0)</label>
                            <input type="number" class="form-control" id="fault-severity" name="severity" step="0.05"
                                min="0.05" max="1.0" value="0.5">
                        </div>
                        <div class="col-md-2 mb-3 d-flex align-items-end">
                            <button type="button" class="btn btn-info w-100" id="add-fault-to-list"><span id="add-to-list-text">添加到列表</span></button>
                        </div>
                    </div>
                </form>

                <h5 class="mt-4" id="scheduled-faults-header">计划的故障列表 (将应用于下一天的仿真):</h5>
                <ul id="scheduled-faults-list" class="list-group mb-3">
                    <!-- 计划的故障将在这里显示 -->
                </ul>
                <button type="button" class="btn btn-primary" id="apply-scheduled-faults"><span id="apply-faults-text">应用计划故障到下一天</span></button>
                <div id="schedule-feedback" class="mt-2"></div>
            </div>
        </div>
    </div>
</div>
<!-- END 故障注入设置表单 -->

<div class="row">
    <div class="col-md-12">
        <div class="card mb-4">
            <div class="card-header" id="anomaly-detection">功率异常检测</div>
            <div class="card-body">
                <div id="anomaly-chart" style="height: 400px;"></div>
            </div>
        </div>
    </div>
</div>

<div class="row mb-5">
    <div class="col-md-12 mb-4">
        <div class="card">
            <div class="card-header" id="power-comparison">实际功率与预测功率对比</div>
            <div class="card-body">
                <div id="comparison-chart" style="height: 450px;"></div>
            </div>
        </div>
    </div>
    <div class="col-md-12">
        <div class="card">
            <div class="card-header" id="error-analysis">预测误差分析</div>
            <div class="card-body">
                <div id="error-chart" style="height: 350px;"></div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    // 定义全局变量
    let anomalyChart, errorChart, comparisonChart;
    let updateTimer; // 实时更新定时器
    let isRealTimeUpdateEnabled = true; // 实时更新开关
    let lastUpdateTime = 0; // 上次更新时间戳
    let updateIntervalSeconds = 5; // 更新间隔，5秒
    let updateFailCount = 0; // 更新失败计数
    let currentLang = 'zh'; // 默认语言
    let plannedFaults = []; // 用于存储在客户端添加的故障

    // 多语言翻译对象
    const translations = {
        'zh': {
            'page-title': '故障诊断',
            'platform-title': '光伏数字孪生平台',
            'fault-diagnosis-header': '故障诊断',
            'realtime-label': '实时更新',
            'manual-refresh-text': '手动刷新',
            'updating-text': '更新中...',
            'diagnosis-results': '故障诊断结果',
            'detected-anomalies': '检测到的异常:',
            'severity-text': '严重程度',
            'no-anomalies': '目前无自动检测到的异常',
            'recommendations': '建议措施:',
            'check-charts-text': '请检查下方图表分析具体情况。',
            'onsite-check-text': '对于持续性异常，考虑安排现场检查。',
            'schedule-fault-header': '为下一天仿真设置计划故障',
            'fault-type-label': '故障类型',
            'partial-shading-option': '部分阴影遮挡',
            'hotspot-option': '组件热斑',
            'aging-option': '组件老化衰减',
            'inverter-option': '逆变器效率下降',
            'start-hour-label': '开始时间 (小时)',
            'end-hour-label': '结束时间 (小时)',
            'severity-label': '严重程度 (0.1-1.0)',
            'add-to-list-text': '添加到列表',
            'scheduled-faults-header': '计划的故障列表 (将应用于下一天的仿真):',
            'apply-faults-text': '应用计划故障到下一天',
            'anomaly-detection': '功率异常检测',
            'power-comparison': '实际功率与预测功率对比',
            'error-analysis': '预测误差分析',
            'loading-text': '正在加载...',
            'anomaly-chart-title': '异常检测 - 功率差异',
            'actual-power': '实际功率',
            'predicted-power': '预测功率',
            'anomaly-flag': '异常标记',
            'comparison-chart-title': '实际功率与预测功率对比',
            'error-chart-title': '预测误差分析',
            'prediction-error': '预测误差',
            'error-threshold': '误差阈值',
            'no-scheduled-faults': '暂无计划的故障',
            'remove-fault': '移除',
            'faults-success': '计划故障应用成功',
            'hours': '小时',
            'severity': '严重程度',
            'error-all-fields': '请填写所有故障参数！',
            'error-start-end-time': '开始时间必须小于结束时间！',
            'error-severity-range': '严重程度必须在 0.05 和 1.0 之间！',
            'error-no-faults': '没有计划的故障可以应用。',
            'error-csrf': '内部错误: CSRF token缺失。',
            'apply-success': '应用成功',
            'apply-failed': '应用故障失败',
            'request-failed': '请求失败'
        },
        'en': {
            'page-title': 'Fault Diagnosis',
            'platform-title': 'PV Digital Twin Platform',
            'fault-diagnosis-header': 'Fault Diagnosis',
            'realtime-label': 'Real-time Update',
            'manual-refresh-text': 'Manual Refresh',
            'updating-text': 'Updating...',
            'diagnosis-results': 'Diagnosis Results',
            'detected-anomalies': 'Detected Anomalies:',
            'severity-text': 'Severity',
            'no-anomalies': 'No anomalies detected at this time',
            'recommendations': 'Recommendations:',
            'check-charts-text': 'Please check the charts below for detailed analysis.',
            'onsite-check-text': 'For persistent anomalies, consider scheduling an on-site inspection.',
            'schedule-fault-header': 'Schedule Faults for Next Day Simulation',
            'fault-type-label': 'Fault Type',
            'partial-shading-option': 'Partial Shading',
            'hotspot-option': 'Module Hotspot',
            'aging-option': 'Module Aging Degradation',
            'inverter-option': 'Inverter Efficiency Drop',
            'start-hour-label': 'Start Hour',
            'end-hour-label': 'End Hour',
            'severity-label': 'Severity (0.1-1.0)',
            'add-to-list-text': 'Add to List',
            'scheduled-faults-header': 'Scheduled Faults List (will be applied to next day simulation):',
            'apply-faults-text': 'Apply Scheduled Faults',
            'anomaly-detection': 'Power Anomaly Detection',
            'power-comparison': 'Actual vs Predicted Power',
            'error-analysis': 'Prediction Error Analysis',
            'loading-text': 'Loading...',
            'anomaly-chart-title': 'Anomaly Detection - Power Difference',
            'actual-power': 'Actual Power',
            'predicted-power': 'Predicted Power',
            'anomaly-flag': 'Anomaly Flag',
            'comparison-chart-title': 'Actual vs Predicted Power Comparison',
            'error-chart-title': 'Prediction Error Analysis',
            'prediction-error': 'Prediction Error',
            'error-threshold': 'Error Threshold',
            'no-scheduled-faults': 'No scheduled faults',
            'remove-fault': 'Remove',
            'faults-success': 'Faults successfully scheduled',
            'hours': 'Hours',
            'severity': 'Severity',
            'error-all-fields': 'Please fill in all fault parameters!',
            'error-start-end-time': 'Start time must be less than end time!',
            'error-severity-range': 'Severity must be between 0.05 and 1.0!',
            'error-no-faults': 'No scheduled faults to apply.',
            'error-csrf': 'Internal error: CSRF token missing.',
            'apply-success': 'Applied successfully',
            'apply-failed': 'Failed to apply faults',
            'request-failed': 'Request failed'
        }
    };

    // 更新图表标题和标签的语言
    function updateChartLanguage(lang) {
        if (anomalyChart) {
            anomalyChart.setOption({
                title: {
                    text: translations[lang]['anomaly-chart-title']
                },
                legend: {
                    data: [
                        translations[lang]['actual-power'],
                        translations[lang]['predicted-power'],
                        translations[lang]['anomaly-flag']
                    ]
                },
                series: [
                    {
                        name: translations[lang]['actual-power']
                    },
                    {
                        name: translations[lang]['predicted-power']
                    },
                    {
                        name: translations[lang]['anomaly-flag']
                    }
                ]
            });
        }
        
        if (comparisonChart) {
            comparisonChart.setOption({
                title: {
                    text: translations[lang]['comparison-chart-title']
                },
                legend: {
                    data: [
                        translations[lang]['actual-power'],
                        translations[lang]['predicted-power']
                    ]
                },
                series: [
                    {
                        name: translations[lang]['actual-power']
                    },
                    {
                        name: translations[lang]['predicted-power']
                    }
                ]
            });
        }
        
        if (errorChart) {
            errorChart.setOption({
                title: {
                    text: translations[lang]['error-chart-title']
                },
                legend: {
                    data: [
                        translations[lang]['prediction-error'],
                        translations[lang]['error-threshold']
                    ]
                },
                series: [
                    {
                        name: translations[lang]['prediction-error']
                    },
                    {
                        name: translations[lang]['error-threshold']
                    }
                ]
            });
        }
    }

    // 监听语言变化事件
    $(document).on('languageChanged', function(event, lang) {
        currentLang = lang;
        
        // 更新页面元素文本
        for (const [id, text] of Object.entries(translations[lang])) {
            $('#' + id).text(text);
        }
        
        // 更新故障类型选项
        if (document.getElementById('fault-type')) {
            const faultTypeSelect = document.getElementById('fault-type');
            const options = faultTypeSelect.options;
            options[0].text = translations[lang]['partial-shading-option'];
            options[1].text = translations[lang]['hotspot-option'];
            options[2].text = translations[lang]['aging-option'];
            options[3].text = translations[lang]['inverter-option'];
        }
        
        // 更新图表语言
        updateChartLanguage(lang);
        
        // 更新已计划的故障列表中的显示文本
        updateScheduledFaultsList();
    });

    document.addEventListener('DOMContentLoaded', function () {
        // 从localStorage加载语言设置
        currentLang = localStorage.getItem('prefLanguage') || 'zh';
        
        // 检查图表容器是否存在
        const anomalyChartEl = document.getElementById('anomaly-chart');
        const errorChartEl = document.getElementById('error-chart');
        const comparisonChartEl = document.getElementById('comparison-chart');

        if (!anomalyChartEl) {
            console.error('图表容器 "anomaly-chart" 不存在');
        }
        if (!errorChartEl) {
            console.error('图表容器 "error-chart" 不存在');
        }
        if (!comparisonChartEl) {
            console.error('图表容器 "comparison-chart" 不存在');
        }

        console.log("故障诊断页面初始化...");
        
        // 初始化图表
        try {
            if (anomalyChart) anomalyChart.dispose();
            if (errorChart) errorChart.dispose();
            if (comparisonChart) comparisonChart.dispose();
            
            const anomalyChartContainer = document.getElementById('anomaly-chart');
            const errorChartContainer = document.getElementById('error-chart');
            const comparisonChartContainer = document.getElementById('comparison-chart');

            // 检查DOM元素是否存在
            if (!anomalyChartContainer) console.error("找不到anomaly-chart容器元素!");
            if (!errorChartContainer) console.error("找不到error-chart容器元素!");
            if (!comparisonChartContainer) console.error("找不到comparison-chart容器元素!");
            
            // 初始化图表
            if (anomalyChartContainer) anomalyChart = echarts.init(anomalyChartContainer);
            if (errorChartContainer) errorChart = echarts.init(errorChartContainer);
            if (comparisonChartContainer) comparisonChart = echarts.init(comparisonChartContainer);
            
            console.log("图表实例已初始化", { 
                anomalyChart: !!anomalyChart, 
                errorChart: !!errorChart, 
                comparisonChart: !!comparisonChart 
            });
            
            // 为图表添加空数据，确保它们被正确渲染
            const emptyOption = {
                xAxis: { type: 'category', data: [] },
                yAxis: { type: 'value' },
                series: [{ data: [], type: 'line' }],
                tooltip: { show: true }
            };
            
            // 设置初始空选项，避免图表显示异常
            if (anomalyChart) anomalyChart.setOption(emptyOption);
            if (errorChart) errorChart.setOption(emptyOption);
            if (comparisonChart) comparisonChart.setOption(emptyOption);
            
        } catch (e) {
            console.error("初始化图表失败:", e);
        }

        // 立即加载第一次数据
        console.log("正在加载初始数据...");
        loadAndUpdateCharts(true);

        // 启动实时更新
        startRealTimeUpdates();

        // 实时更新开关事件处理
        const realTimeUpdateSwitch = document.getElementById('real-time-update');
        if (realTimeUpdateSwitch) {
            realTimeUpdateSwitch.addEventListener('change', function () {
                isRealTimeUpdateEnabled = this.checked;
                if (isRealTimeUpdateEnabled) {
                    console.log('故障诊断实时更新已启用');
                    // 立即更新一次数据
                    loadAndUpdateCharts(true);
                } else {
                    console.log('故障诊断实时更新已暂停');
                }
                updateLastUpdateTime();
            });
        }
        
        // 手动刷新按钮事件处理
        const manualRefreshButton = document.getElementById('manual-refresh');
        if (manualRefreshButton) {
            manualRefreshButton.addEventListener('click', function () {
                console.log('手动刷新故障诊断数据');
                loadAndUpdateCharts(true);
            });
        }

        // 故障计划功能相关事件绑定
        const addFaultButton = document.getElementById('add-fault-to-list');
        const applyScheduledFaultsButton = document.getElementById('apply-scheduled-faults');
        const scheduledFaultsList = document.getElementById('scheduled-faults-list');
        const scheduleFeedback = document.getElementById('schedule-feedback');

        if (addFaultButton) {
            addFaultButton.addEventListener('click', function () {
                const faultTypeSelect = document.getElementById('fault-type');
                const faultTypeValue = faultTypeSelect.value;
                const faultTypeText = faultTypeSelect.options[faultTypeSelect.selectedIndex].text;
                const startHour = document.getElementById('fault-start-hour').value;
                const endHour = document.getElementById('fault-end-hour').value;
                const severity = document.getElementById('fault-severity').value;

                if (!faultTypeValue || startHour === '' || endHour === '' || severity === '') {
                    alert(translations[currentLang]['error-all-fields']);
                    return;
                }
                if (parseInt(startHour) >= parseInt(endHour)) {
                    alert(translations[currentLang]['error-start-end-time']);
                    return;
                }
                if (parseFloat(severity) < 0.05 || parseFloat(severity) > 1.0) {
                    alert(translations[currentLang]['error-severity-range']);
                    return;
                }

                const fault = {
                    type: faultTypeValue,
                    type_display: faultTypeText,
                    start_hour: parseInt(startHour),
                    end_hour: parseInt(endHour),
                    severity: parseFloat(severity)
                };
                plannedFaults.push(fault);
                renderScheduledFaults();
            });
        }

        if (applyScheduledFaultsButton) {
            applyScheduledFaultsButton.addEventListener('click', function () {
                if (plannedFaults.length === 0) {
                    scheduleFeedback.innerHTML = `<div class="alert alert-warning">${translations[currentLang]['error-no-faults']}</div>`;
                    return;
                }

                const csrfTokenElement = document.querySelector('[name=csrfmiddlewaretoken]');
                if (!csrfTokenElement) {
                    console.error('CSRF token not found!');
                    scheduleFeedback.innerHTML = `<div class="alert alert-danger">${translations[currentLang]['error-csrf']}</div>`;
                    return;
                }
                const csrfToken = csrfTokenElement.value;

                fetch('/schedule-faults/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({ faults: plannedFaults })
                })
                    .then(response => {
                        if (!response.ok) {
                            return response.json().then(err => { throw new Error(err.message || translations[currentLang]['request-failed']) });
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (data.status === 'success') {
                            scheduleFeedback.innerHTML = `<div class="alert alert-success">${data.message || translations[currentLang]['faults-success']}</div>`;
                            plannedFaults = [];
                            renderScheduledFaults();
                        } else {
                            scheduleFeedback.innerHTML = `<div class="alert alert-danger">${translations[currentLang]['apply-failed']}: ${data.message}</div>`;
                        }
                    })
                    .catch(error => {
                        scheduleFeedback.innerHTML = `<div class="alert alert-danger">${translations[currentLang]['request-failed']}: ${error.message}</div>`;
                        console.error('Error scheduling faults:', error);
                    });
            });
        }

        renderScheduledFaults(); // 初始化列表显示
        
        // 初始应用语言
        for (const [id, text] of Object.entries(translations[currentLang])) {
            $('#' + id).text(text);
        }

        // 停止实时数据更新
        function stopRealTimeUpdates() {
            if (updateTimer) {
                clearInterval(updateTimer);
                updateTimer = null;
                console.log('实时更新已停止');
            }
        }
    });

    // 渲染已计划故障列表
    function renderScheduledFaults() {
        const scheduledFaultsList = document.getElementById('scheduled-faults-list');
        if (!scheduledFaultsList) return;
        
        scheduledFaultsList.innerHTML = ''; // 清空列表
        if (plannedFaults.length === 0) {
            const listItem = document.createElement('li');
            listItem.classList.add('list-group-item');
            listItem.textContent = translations[currentLang]['no-scheduled-faults'];
            scheduledFaultsList.appendChild(listItem);
        } else {
            plannedFaults.forEach((fault, index) => {
                const listItem = document.createElement('li');
                listItem.classList.add('list-group-item', 'd-flex', 'justify-content-between', 'align-items-center');
                listItem.dataset.fault = JSON.stringify(fault);
                
                const faultInfo = document.createElement('span');
                faultInfo.classList.add('fault-info');
                
                const hoursText = currentLang === 'zh' ? '小时' : 'Hours';
                const severityText = translations[currentLang]['severity'];
                faultInfo.textContent = `${fault.type_display}: ${fault.start_hour}-${fault.end_hour} ${hoursText}, ${severityText}: ${fault.severity.toFixed(2)}`;
                
                const removeButton = document.createElement('button');
                removeButton.type = 'button';
                removeButton.classList.add('btn', 'btn-sm', 'btn-danger', 'remove-fault-btn');
                removeButton.textContent = translations[currentLang]['remove-fault'];
                removeButton.dataset.index = index;
                removeButton.addEventListener('click', function() {
                    const indexToRemove = parseInt(this.dataset.index);
                    plannedFaults.splice(indexToRemove, 1);
                    renderScheduledFaults();
                });
                
                listItem.appendChild(faultInfo);
                listItem.appendChild(removeButton);
                scheduledFaultsList.appendChild(listItem);
            });
        }
    }

    // 更新已计划的故障列表显示
    function updateScheduledFaultsList() {
        const faultTypeMap = {
            'PARTIAL_SHADING': { 
                'zh': '部分阴影遮挡', 
                'en': 'Partial Shading' 
            },
            'HOTSPOT': { 
                'zh': '组件热斑', 
                'en': 'Module Hotspot' 
            },
            'AGING_DEGRADATION': { 
                'zh': '组件老化衰减', 
                'en': 'Module Aging Degradation' 
            },
            'INVERTER_EFFICIENCY_DROP': { 
                'zh': '逆变器效率下降', 
                'en': 'Inverter Efficiency Drop' 
            }
        };

        const faultsList = document.getElementById('scheduled-faults-list');
        if (faultsList) {
            Array.from(faultsList.children).forEach(item => {
                const faultData = JSON.parse(item.dataset.fault || '{}');
                if (faultData && faultData.type && faultTypeMap[faultData.type]) {
                    const typeText = faultTypeMap[faultData.type][currentLang];
                    const severityText = translations[currentLang]['severity-text'];
                    const hours = currentLang === 'zh' ? '小时' : 'Hours';
                    item.querySelector('.fault-info').textContent = `${typeText} - ${faultData.start_hour}-${faultData.end_hour} ${hours}, ${severityText}: ${faultData.severity}`;
                }
            });
        }
    }

    // 启动实时更新
    function startRealTimeUpdates() {
        // 清除可能存在的旧定时器
        if (updateTimer) {
            clearInterval(updateTimer);
            console.log('清除旧的更新定时器');
        }
        
        // 建立新的更新定时器
        updateTimer = setInterval(() => {
            if (isRealTimeUpdateEnabled) {
                loadAndUpdateCharts();
            }
        }, updateIntervalSeconds * 1000);
        
        console.log(`实时更新启动成功，间隔：${updateIntervalSeconds}秒`);
        
        // 页面卸载时清理定时器
        window.addEventListener('beforeunload', function() {
            if (updateTimer) {
                clearInterval(updateTimer);
                console.log('页面卸载，清理更新定时器');
            }
        });
    }

    // 更新上次更新时间显示
    function updateLastUpdateTime() {
        const lastUpdateElement = document.getElementById('last-update-time');
        if (lastUpdateElement) {
            const now = new Date();
            const timeStr = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`;
            lastUpdateElement.textContent = `${currentLang === 'zh' ? '上次更新' : 'Last update'}: ${timeStr}`;
        }
    }

    function updateFaultCauses(anomalyData) {
        const faultCausesList = document.getElementById('fault-causes-list');
        faultCausesList.innerHTML = '';

        if (anomalyData && anomalyData.length > 0) {
            anomalyData.forEach(anomaly => {
                const listItem = document.createElement('li');
                const severityText = translations[currentLang]['severity-text'];
                const occurrenceText = currentLang === 'zh' ? '发生于' : 'Occurred at';
                listItem.textContent = `${anomaly.type} - ${severityText}: ${anomaly.severity.toFixed(2)} (${occurrenceText}: ${anomaly.timestamp})`;
                faultCausesList.appendChild(listItem);
            });
        } else {
            const listItem = document.createElement('li');
            listItem.id = "no-anomalies";
            listItem.textContent = translations[currentLang]['no-anomalies'];
            faultCausesList.appendChild(listItem);
        }
    }

    // 核心函数：加载数据并更新所有图表
    function loadAndUpdateCharts(forceUpdate = false) {
        const now = Date.now();
        const timeSinceLastUpdate = (now - lastUpdateTime) / 1000;
        
        // 检查是否需要更新（强制更新或者已经过了更新间隔）
        if (!forceUpdate && timeSinceLastUpdate < updateIntervalSeconds) {
            console.log(`距离上次更新仅过了 ${timeSinceLastUpdate.toFixed(1)}秒，小于更新间隔，跳过本次更新`);
            return;
        }
        
        console.log(`故障诊断 - 开始更新图表 (强制更新: ${forceUpdate})`);
        lastUpdateTime = now;
        
        // 显示更新指示器
        const updateIndicator = document.getElementById('update-indicator');
        if (updateIndicator) {
            updateIndicator.classList.remove('d-none');
        }
        
        // 使用时间戳参数避免缓存
        const cacheBreaker = Date.now();
        
        // 先创建空的数据结构，确保即使API失败也有默认数据可用
        let defaultSimData = {
            timestamps: [],
            ac_power: [],
            ghi: []
        };
        
        // 生成当天的24小时时间戳
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        for (let i = 0; i < 24; i++) {
            const hourTime = new Date(today);
            hourTime.setHours(i);
            defaultSimData.timestamps.push(hourTime.toISOString());
            
            // 生成一些基于时间的默认值
            // 白天(6-18点)有太阳时产生电力
            const isDaytime = i >= 6 && i < 18;
            const hoursFromNoon = Math.abs(i - 12);
            const powerFactor = isDaytime ? Math.cos(hoursFromNoon * Math.PI / 12) : 0;
            const basePower = isDaytime ? 5000 * Math.max(0, powerFactor) : 0;
            
            defaultSimData.ac_power.push(basePower);
            defaultSimData.ghi.push(isDaytime ? 1000 * Math.max(0, powerFactor) : 0);
        }
        
        // 同时处理多个API请求
        Promise.all([
            fetch(`/api/simulation-data/?_=${cacheBreaker}`)
                .then(response => {
                    if (!response.ok) {
                        console.warn(`仿真数据API响应状态码: ${response.status}`);
                        throw new Error(`请求仿真数据失败: ${response.status}`);
                    }
                    return response.json();
                })
                .catch(error => {
                    console.error('获取仿真数据时出错:', error);
                    return defaultSimData;  // 出错时返回默认数据
                }),
            fetch(`/api/detected-anomalies/?_=${cacheBreaker}`)
                .then(response => {
                    if (!response.ok) {
                        console.warn(`异常数据API响应状态码: ${response.status}`);
                        throw new Error(`请求异常数据失败: ${response.status}`);
                    }
                    return response.json();
                })
                .catch(error => {
                    console.error('获取异常数据时出错:', error);
                    return [];  // 出错时返回空数组
                })
        ])
        .then(([simData, anomalyApiResponse]) => {
            console.log('故障诊断 - API响应数据:', {
                'simData结构': simData ? Object.keys(simData) : null,
                'timestamps长度': simData && simData.timestamps ? simData.timestamps.length : 0,
                'anomalyApiResponse类型': typeof anomalyApiResponse,
                'anomalyApiResponse是数组': Array.isArray(anomalyApiResponse),
            });
            
            // 确保simData有有效的结构
            if (!simData || !simData.timestamps || !Array.isArray(simData.timestamps)) {
                console.warn('simData无效或缺少timestamps数组，使用默认数据');
                simData = defaultSimData;
            }
            
            // 处理响应并更新图表
            let anomalyData = [];
            if (Array.isArray(anomalyApiResponse)) {
                anomalyData = anomalyApiResponse;
            } else if (anomalyApiResponse && Array.isArray(anomalyApiResponse.detected_anomalies)) {
                anomalyData = anomalyApiResponse.detected_anomalies;
            }
            
            console.log(`准备处理数据: ${simData.timestamps.length} 个时间点, ${anomalyData.length} 个异常`);
            
            try {
                // 直接调用处理异常及更新图表的函数
                processAnomaliesAndUpdateCharts(simData, anomalyData);
                updateFailCount = 0;  // 重置失败计数
            } catch (error) {
                console.error('处理数据或更新图表时出错:', error);
                updateFailCount++;
            }
            
            // 隐藏更新指示器
            if (updateIndicator) {
                updateIndicator.classList.add('d-none');
            }
            
            // 更新时间显示
            updateLastUpdateTime();
        })
        .catch(error => {
            console.error('故障诊断 - 获取数据过程中发生错误:', error);
            updateFailCount++;
            
            // 隐藏更新指示器
            if (updateIndicator) {
                updateIndicator.classList.add('d-none');
            }
            
            updateLastUpdateTime();
            
            // 如果连续失败多次，尝试重新初始化图表
            if (updateFailCount >= 3) {
                console.warn(`故障诊断 - 连续 ${updateFailCount} 次更新失败，尝试重新初始化图表...`);
                reinitializeCharts();
            }
        });
    }
    
    // 重新初始化图表函数
    function reinitializeCharts() {
        try {
            console.log('尝试重新初始化所有图表...');
            
            // 清理现有图表实例
            if (anomalyChart) {
                try { anomalyChart.dispose(); } catch(e) { console.error('清理异常图表失败', e); }
                anomalyChart = null;
            }
            if (comparisonChart) {
                try { comparisonChart.dispose(); } catch(e) { console.error('清理对比图表失败', e); }
                comparisonChart = null;
            }
            if (errorChart) {
                try { errorChart.dispose(); } catch(e) { console.error('清理误差图表失败', e); }
                errorChart = null;
            }
            
            // 重新创建图表实例
            const anomalyChartContainer = document.getElementById('anomaly-chart');
            const comparisonChartContainer = document.getElementById('comparison-chart');
            const errorChartContainer = document.getElementById('error-chart');
            
            if (anomalyChartContainer) anomalyChart = echarts.init(anomalyChartContainer);
            if (comparisonChartContainer) comparisonChart = echarts.init(comparisonChartContainer);
            if (errorChartContainer) errorChart = echarts.init(errorChartContainer);
            
            // 重置失败计数
            updateFailCount = 0;
            
            // 设置初始空选项
            const emptyOption = {
                xAxis: { type: 'category', data: [] },
                yAxis: { type: 'value' },
                series: [{ data: [], type: 'line' }]
            };
            
            if (anomalyChart) anomalyChart.setOption(emptyOption);
            if (comparisonChart) comparisonChart.setOption(emptyOption);
            if (errorChart) errorChart.setOption(emptyOption);
            
            console.log('图表重新初始化完成');
        } catch (error) {
            console.error('重新初始化图表失败:', error);
        }
    }

    // 处理异常数据并更新图表
    function processAnomaliesAndUpdateCharts(simData, anomalyData) {
        console.log('处理异常数据并更新图表');
        
        // 检查数据有效性
        if (!simData || !simData.timestamps || simData.timestamps.length === 0) {
            console.error('processAnomaliesAndUpdateCharts: 模拟数据无效或为空');
            return;
        }
        
        // 确保anomalyData是数组
        if (!Array.isArray(anomalyData)) {
            console.warn('异常数据无效，使用空数组代替');
            anomalyData = [];
        }
        
        console.log(`处理数据: ${simData.timestamps.length} 个时间点，${anomalyData.length} 个异常点`);
        
        // 检查异常数据是否为空，使用测试异常点
        if (anomalyData.length === 0) {
            console.log('没有检测到实际异常，将在图表中自动添加模拟异常点用于演示');
            // 注意：此处我们不需要手动添加模拟数据，因为各个图表更新函数中已经添加了这个逻辑
        }
        
        try {
            // 更新故障原因列表
            updateFaultCauses(anomalyData);
            
            // 更新主图表
            updateAnomalyChart(simData, anomalyData);
            
            // 更新其他图表
            updateComparisonAndErrorCharts(simData, anomalyData);
            
            // 更新完成后，触发window的resize事件，确保所有图表都正确渲染
            setTimeout(() => {
                console.log('强制刷新所有图表尺寸');
                if (anomalyChart) anomalyChart.resize();
                if (comparisonChart) comparisonChart.resize();
                if (errorChart) errorChart.resize();
            }, 100);
            
            console.log('所有图表更新完成');
        } catch (error) {
            console.error('处理异常数据并更新图表失败:', error);
        }
    }
    
    // 更新主异常图表
    function updateAnomalyChart(simData, anomalyData) {
        console.log('更新主异常检测图表');
        
        // 检查simData的有效性
        if (!simData || typeof simData !== 'object') {
            console.error('updateAnomalyChart: 无效的simData对象');
            return;
        }
        
        const timestamps = simData.timestamps || [];
        const acPower = simData.ac_power || [];
        const ghi = simData.ghi || [];
        
        // 没有数据时提前退出
        if (!timestamps.length || !acPower.length) {
            console.error('updateAnomalyChart: 没有有效的时间戳或功率数据');
            return;
        }
        
        const autoDetectedAnomalyPoints = [];
        const autoDetectedAnomalyValues = [];
        const autoDetectedAnomalySeverity = [];
        
        // 处理异常点数据
        if (Array.isArray(anomalyData)) {
            anomalyData.forEach(anomaly => {
                if (!anomaly || !anomaly.timestamp) return;
                
                const timestamp = anomaly.timestamp;
                const idx = timestamps.findIndex(ts => {
                    if (!ts) return false;
                    try {
                        // 使用更健壮的日期比较方法
                        const d1 = new Date(ts);
                        const d2 = new Date(timestamp);
                        
                        if (isNaN(d1.getTime()) || isNaN(d2.getTime())) return false;
                        
                        return d1.getFullYear() === d2.getFullYear() &&
                            d1.getMonth() === d2.getMonth() &&
                            d1.getDate() === d2.getDate() &&
                            d1.getHours() === d2.getHours();
                    } catch (e) {
                        return false;
                    }
                });
                
                if (idx !== -1) {
                    autoDetectedAnomalyPoints.push(idx);
                    
                    // 如果异常点有自己的值，使用它，否则使用模拟数据中的值
                    const value = anomaly.value !== undefined ? anomaly.value : acPower[idx];
                    autoDetectedAnomalyValues.push(value);
                    autoDetectedAnomalySeverity.push(anomaly.severity);
                }
            });
        }
        
        // 如果没有检测到异常点，添加一些模拟异常点以确保图表可以显示
        if (autoDetectedAnomalyPoints.length === 0) {
            console.log('没有检测到异常点，添加模拟异常点以验证图表是否正常显示');
            
            // 添加2-3个模拟异常点
            const numMockAnomalies = 2 + Math.floor(Math.random());
            
            // 选择合适的时间点添加模拟异常
            for (let i = 0; i < numMockAnomalies; i++) {
                // 选择白天的点（避开夜间零功率时段）
                const dayIndices = timestamps.map((ts, idx) => {
                    const hour = new Date(ts).getHours();
                    return hour >= 8 && hour <= 18 && acPower[idx] > 0 ? idx : -1;
                }).filter(idx => idx !== -1);
                
                if (dayIndices.length > 0) {
                    // 随机选择一个白天的时间点
                    const randomIdx = dayIndices[Math.floor(Math.random() * dayIndices.length)];
                    
                    if (acPower[randomIdx] > 0) {
                        autoDetectedAnomalyPoints.push(randomIdx);
                        
                        // 制造一个偏差值
                        const originalPower = acPower[randomIdx];
                        const anomalyPower = originalPower * (0.7 + Math.random() * 0.6); // 70%-130%
                        
                        autoDetectedAnomalyValues.push(anomalyPower);
                        autoDetectedAnomalySeverity.push(0.5 + Math.random() * 0.5); // 严重程度0.5-1.0
                    }
                }
            }
            
            console.log(`添加了 ${autoDetectedAnomalyPoints.length} 个模拟异常点`);
        }
        
        // 准备图表数据
        const seriesDataAcPower = acPower.map(p => p != null ? p / 1000 : null);
        const seriesDataGhi = ghi.map(g => g != null ? g : null);
        
        // 异常标记数据
        const seriesDataAnomaly = acPower.map((value, index) => {
            if (autoDetectedAnomalyPoints.includes(index) && value != null) {
                // 使用异常点对应的值
                const anomalyIdx = autoDetectedAnomalyPoints.indexOf(index);
                return autoDetectedAnomalyValues[anomalyIdx] / 1000;
            }
            return '-';
        });
        
        try {
            if (!anomalyChart) {
                console.warn('异常图表实例不存在，重新创建');
                const container = document.getElementById('anomaly-chart');
                if (!container) {
                    console.error('找不到anomaly-chart容器');
                    return;
                }
                anomalyChart = echarts.init(container);
            }
            
            // 使用当前语言设置的文本
            const chartTitle = translations[currentLang]['anomaly-chart-title'] || '异常检测 - 功率差异';
            const acPowerText = translations[currentLang]['actual-power'] || '实际功率';
            const ghiText = translations[currentLang]['irradiance'] || '辐照度';
            const anomalyFlagText = translations[currentLang]['anomaly-flag'] || '异常标记';
            const severityText = translations[currentLang]['severity-text'] || '严重程度';
            const powerUnitText = currentLang === 'zh' ? 'kW' : 'kW';
            const ghiUnitText = currentLang === 'zh' ? 'W/m²' : 'W/m²';
            
            // 格式化X轴标签，显示时间而不是ISO字符串
            const formattedXAxisLabels = timestamps.map(ts => {
                try {
                    const date = new Date(ts);
                    return `${date.getHours()}:00`;
                } catch (e) {
                    return ts;
                }
            });
            
            // 创建完整的图表配置
            const option = {
                title: { 
                    text: chartTitle,
                    left: 'center'
                },
                tooltip: {
                    trigger: 'axis',
                    axisPointer: { type: 'cross' },
                    formatter: function (params) {
                        let result = '';
                        
                        // 获取时间点
                        if (params && params.length > 0 && params[0].name) {
                            try {
                                const idx = params[0].dataIndex;
                                if (idx >= 0 && idx < timestamps.length) {
                                    const date = new Date(timestamps[idx]);
                                    result = `${date.getFullYear()}-${date.getMonth()+1}-${date.getDate()} ${date.getHours()}:00<br/>`;
                                } else {
                                    result = params[0].name + '<br/>';
                                }
                            } catch (e) {
                                result = params[0].name + '<br/>';
                            }
                        }
                        
                        // 添加各系列数据
                        params.forEach(param => {
                            if (param.seriesName === anomalyFlagText) {
                                if (param.value !== '-' && param.value != null) {
                                    const idx = autoDetectedAnomalyPoints.indexOf(param.dataIndex);
                                    if (idx !== -1) {
                                        result += `<span style="color:red;font-weight:bold">⚠ ${anomalyFlagText}</span>: ${parseFloat(param.value).toFixed(2)} ${powerUnitText}<br/>`;
                                        result += `${severityText}: ${autoDetectedAnomalySeverity[idx].toFixed(2)}<br/>`;
                                    }
                                }
                            } else if (param.value != null && param.value !== '-') {
                                result += `${param.marker} ${param.seriesName}: ${parseFloat(param.value).toFixed(2)} ${param.seriesName === ghiText ? ghiUnitText : powerUnitText}<br/>`;
                            }
                        });
                        return result;
                    }
                },
                legend: { 
                    data: [acPowerText, ghiText, anomalyFlagText],
                    bottom: '0%'
                },
                grid: {
                    left: '3%',
                    right: '4%',
                    bottom: '60px',
                    top: '60px',
                    containLabel: true
                },
                xAxis: { 
                    type: 'category', 
                    data: formattedXAxisLabels,
                    axisLabel: {
                        interval: Math.ceil(formattedXAxisLabels.length / 12), // 根据数据量调整间隔
                        showMaxLabel: true
                    }
                },
                yAxis: [
                    { 
                        type: 'value', 
                        name: powerUnitText, 
                        position: 'left', 
                        min: 0, 
                        axisLabel: { formatter: `{value} ${powerUnitText}` } 
                    },
                    { 
                        type: 'value', 
                        name: ghiUnitText, 
                        position: 'right', 
                        min: 0, 
                        axisLabel: { formatter: `{value} ${ghiUnitText}` } 
                    }
                ],
                series: [
                    { 
                        name: acPowerText, 
                        type: 'line', 
                        data: seriesDataAcPower, 
                        smooth: true,
                        showSymbol: false,
                        itemStyle: {
                            color: '#5470c6'
                        },
                        emphasis: {
                            focus: 'series'
                        }
                    },
                    { 
                        name: ghiText, 
                        type: 'line', 
                        yAxisIndex: 1, 
                        data: seriesDataGhi, 
                        smooth: true,
                        showSymbol: false,
                        itemStyle: {
                            color: '#91cc75'
                        },
                        emphasis: {
                            focus: 'series'
                        }
                    },
                    {
                        name: anomalyFlagText,
                        type: 'scatter',
                        symbolSize: function (val, params) {
                            const idx = autoDetectedAnomalyPoints.indexOf(params.dataIndex);
                            return idx !== -1 && val !== '-' ? 15 + autoDetectedAnomalySeverity[idx] * 15 : 0;
                        },
                        data: seriesDataAnomaly,
                        itemStyle: { 
                            color: '#c23531',
                            borderColor: '#000',
                            borderWidth: 2,
                            shadowColor: 'rgba(0, 0, 0, 0.5)',
                            shadowBlur: 10
                        },
                        symbol: 'triangle',  // 使用三角形符号更醒目
                        emphasis: {
                            focus: 'self'
                        }
                    }
                ]
            };
            
            // 注意: 使用true参数强制重置而不是合并选项
            anomalyChart.setOption(option, true);
            console.log('异常检测图表更新完成');
            
            // 触发resize以确保正确绘制
            anomalyChart.resize();
            
        } catch (error) {
            console.error('异常检测图表更新失败:', error);
        }
    }
    
    // 更新对比图表和误差图表
    function updateComparisonAndErrorCharts(simData, anomalyData) {
        console.log('更新功率对比图表和误差图表');
        
        // 检查simData的有效性
        if (!simData || typeof simData !== 'object') {
            console.error('无效的simData对象:', simData);
            return;
        }
        
        const timestamps = simData.timestamps || [];
        const acPower = simData.ac_power || [];
        
        // 没有数据时提前退出
        if (!timestamps.length || !acPower.length) {
            console.error('没有有效的时间戳或功率数据');
            
            // 创建一些模拟数据以确保图表能显示
            const now = new Date();
            const mockTimestamps = [];
            const mockPower = [];
            const mockPredicted = [];
            
            for (let i = 0; i < 24; i++) {
                const time = new Date(now);
                time.setHours(i);
                time.setMinutes(0);
                time.setSeconds(0);
                mockTimestamps.push(time.toISOString());
                
                // 生成一些基于时间的模拟数据
                const basePower = 5 + 20 * Math.sin(Math.PI * i / 12); // 0-24小时的正弦曲线
                const randomFactor = 0.8 + Math.random() * 0.4;        // 0.8-1.2的随机因子
                
                mockPower.push(basePower * randomFactor);
                mockPredicted.push(basePower);
            }
            
            // 使用模拟数据
            console.log('使用模拟数据以确保图表显示');
            updateComparisonChartWithData(mockTimestamps, mockPower, mockPredicted, []);
            updateErrorChartWithData(mockTimestamps, mockPower, mockPredicted);
            return;
        }
        
        // 准备数据
        const recentPoints = Math.min(timestamps.length, 48);
        const recentTimestamps = timestamps.slice(-recentPoints);
        const recentAcPower = acPower.map(p => p != null ? p / 1000 : null).slice(-recentPoints);
        
        // 生成模拟的预测功率数据
        const predictedPower = acPower.map(p => p != null ? p * (0.9 + Math.random() * 0.2) : null);
        const recentPredictedPower = predictedPower.map(p => p != null ? p / 1000 : null).slice(-recentPoints);
        
        // 为对比图表准备异常点数据
        const recentAnomalyPoints = [];
        const recentAnomalySeverity = [];
        const recentAnomalyValues = [];
        
        // 查找哪些异常点在最近的时间范围内
        if (Array.isArray(anomalyData)) {
            anomalyData.forEach(anomaly => {
                if (!anomaly || !anomaly.timestamp) return;
                
                const timestamp = anomaly.timestamp;
                const idx = recentTimestamps.findIndex(ts => {
                    if (!ts) return false;
                    try {
                        const d1 = new Date(ts);
                        const d2 = new Date(timestamp);
                        if (isNaN(d1.getTime()) || isNaN(d2.getTime())) return false;
                        return d1.getFullYear() === d2.getFullYear() &&
                               d1.getMonth() === d2.getMonth() &&
                               d1.getDate() === d2.getDate() &&
                               d1.getHours() === d2.getHours();
                    } catch (e) {
                        return false;
                    }
                });
                
                if (idx !== -1) {
                    recentAnomalyPoints.push(idx);
                    recentAnomalySeverity.push(anomaly.severity);
                    // 如果异常点有自己的值，使用它，否则使用模拟数据中的对应值
                    const value = anomaly.value !== undefined ? anomaly.value / 1000 : recentAcPower[idx];
                    recentAnomalyValues.push(value);
                }
            });
        }
        
        // 计算预测误差
        const errors = [];
        for (let i = 0; i < acPower.length; i++) {
            if (acPower[i] != null && predictedPower[i] != null) {
                errors.push((acPower[i] - predictedPower[i]) / 1000);
            } else {
                errors.push(null);
            }
        }
        const recentErrors = errors.slice(-recentPoints);
        
        // 使用提取出的函数更新图表
        updateComparisonChartWithData(recentTimestamps, recentAcPower, recentPredictedPower, recentAnomalyPoints);
        updateErrorChartWithData(recentTimestamps, recentAcPower, recentPredictedPower);
    }
    
    // 更新功率对比图表
    function updateComparisonChartWithData(timestamps, actualPower, predictedPower, anomalyPoints) {
        try {
            if (!comparisonChart) {
                console.warn('对比图表实例不存在，尝试创建');
                const container = document.getElementById('comparison-chart');
                if (container) {
                    comparisonChart = echarts.init(container);
                } else {
                    console.error('无法找到comparison-chart容器');
                    return;
                }
            }
            
            // 使用当前语言设置的文本
            const comparisonChartTitle = translations[currentLang]['comparison-chart-title'];
            const actualPowerText = translations[currentLang]['actual-power'];
            const predictedPowerText = translations[currentLang]['predicted-power'];
            const powerUnitText = currentLang === 'zh' ? 'kW' : 'kW';
            
            comparisonChart.setOption({
                title: {
                    text: comparisonChartTitle
                },
                tooltip: {
                    trigger: 'axis',
                    formatter: function (params) {
                        const actualParam = params.find(p => p.seriesName === actualPowerText);
                        const predictedParam = params.find(p => p.seriesName === predictedPowerText);
                        
                        let result = params[0].name + '<br/>';
                        if (actualParam && actualParam.value != null) {
                            result += `${actualPowerText}: ${parseFloat(actualParam.value).toFixed(2)} ${powerUnitText}<br/>`;
                        }
                        if (predictedParam && predictedParam.value != null) {
                            result += `${predictedPowerText}: ${parseFloat(predictedParam.value).toFixed(2)} ${powerUnitText}<br/>`;
                        }
                        
                        // 计算并显示差异百分比
                        if (actualParam && predictedParam && 
                            actualParam.value != null && predictedParam.value != null && 
                            actualParam.value > 0) {
                            const diffPercent = Math.abs((actualParam.value - predictedParam.value) / actualParam.value * 100);
                            result += `${currentLang === 'zh' ? '差异' : 'Difference'}: ${diffPercent.toFixed(1)}%`;
                        }
                        
                        return result;
                    }
                },
                legend: {
                    data: [actualPowerText, predictedPowerText]
                },
                xAxis: {
                    type: 'category',
                    data: timestamps,
                    axisLabel: {
                        formatter: function (value) {
                            try {
                                const date = new Date(value);
                                return `${date.getHours()}:00`;
                            } catch (e) {
                                return value;
                            }
                        }
                    }
                },
                yAxis: {
                    type: 'value',
                    name: powerUnitText,
                    min: function (value) {
                        return Math.max(0, value.min * 0.9); // 确保最小值不小于0
                    },
                    axisLabel: {
                        formatter: `{value} ${powerUnitText}`
                    }
                },
                series: [
                    {
                        name: actualPowerText,
                        type: 'line',
                        data: actualPower,
                        smooth: true,
                        itemStyle: {
                            color: '#5470c6'
                        },
                        markPoint: {
                            symbol: 'pin',
                            symbolSize: function (value, params) {
                                return anomalyPoints.includes(params.dataIndex) ? 50 : 0;
                            },
                            data: anomalyPoints.map(idx => {
                                return {
                                    name: currentLang === 'zh' ? '异常' : 'Anomaly',
                                    coord: [timestamps[idx], actualPower[idx]],
                                    value: actualPower[idx] != null ? actualPower[idx].toFixed(2) : 'N/A',
                                    itemStyle: {
                                        color: '#c23531'
                                    }
                                };
                            })
                        }
                    },
                    {
                        name: predictedPowerText,
                        type: 'line',
                        data: predictedPower,
                        smooth: true,
                        itemStyle: {
                            color: '#91cc75'
                        }
                    }
                ],
                grid: {
                    left: '5%',
                    right: '5%',
                    bottom: '10%',
                    containLabel: true
                }
            }, true);
            
            console.log('功率对比图表更新完成');
        } catch (error) {
            console.error('更新功率对比图表失败:', error);
        }
    }
    
    // 更新误差图表
    function updateErrorChartWithData(timestamps, actualPower, predictedPower) {
        try {
            if (!errorChart) {
                console.warn('误差图表实例不存在，尝试创建');
                const container = document.getElementById('error-chart');
                if (container) {
                    errorChart = echarts.init(container);
                } else {
                    console.error('无法找到error-chart容器');
                    return;
                }
            }
            
            // 使用当前语言设置的文本
            const errorChartTitle = translations[currentLang]['error-chart-title'];
            const predictionErrorText = translations[currentLang]['prediction-error'];
            const errorThresholdText = translations[currentLang]['error-threshold'];
            const powerUnitText = currentLang === 'zh' ? 'kW' : 'kW';
            
            // 计算误差
            const errors = [];
            for (let i = 0; i < actualPower.length; i++) {
                if (actualPower[i] != null && predictedPower[i] != null) {
                    errors.push(actualPower[i] - predictedPower[i]);
                } else {
                    errors.push(null);
                }
            }
            
            // 计算误差阈值
            const validErrors = errors.filter(e => e != null);
            const maxAbsError = validErrors.length > 0 ? 
                Math.max(...validErrors.map(Math.abs)) : 1;
            const errorThreshold = maxAbsError * 0.5; // 设置一个合理的阈值，为最大误差的50%
            
            // 准备误差阈值数据 - 上下两条线
            const upperThreshold = timestamps.map(() => errorThreshold);
            const lowerThreshold = timestamps.map(() => -errorThreshold);
            
            errorChart.setOption({
                title: {
                    text: errorChartTitle
                },
                tooltip: {
                    trigger: 'axis',
                    formatter: function (params) {
                        const errorParam = params.find(p => p.seriesName === predictionErrorText);
                        
                        let result = params[0].name + '<br/>';
                        if (errorParam && errorParam.value != null) {
                            result += `${predictionErrorText}: ${parseFloat(errorParam.value).toFixed(3)} ${powerUnitText}<br/>`;
                            
                            // 判断误差严重程度
                            const absError = Math.abs(errorParam.value);
                            let severity;
                            if (absError > errorThreshold) {
                                severity = currentLang === 'zh' ? '严重' : 'Severe';
                            } else if (absError > errorThreshold * 0.5) {
                                severity = currentLang === 'zh' ? '中等' : 'Moderate';
                            } else {
                                severity = currentLang === 'zh' ? '轻微' : 'Minor';
                            }
                            
                            result += `${currentLang === 'zh' ? '误差程度' : 'Error Level'}: ${severity}`;
                        }
                        
                        return result;
                    }
                },
                legend: {
                    data: [predictionErrorText, errorThresholdText]
                },
                xAxis: {
                    type: 'category',
                    data: timestamps,
                    axisLabel: {
                        formatter: function (value) {
                            try {
                                const date = new Date(value);
                                return `${date.getHours()}:00`;
                            } catch (e) {
                                return value;
                            }
                        }
                    }
                },
                yAxis: {
                    type: 'value',
                    name: currentLang === 'zh' ? '误差 (kW)' : 'Error (kW)',
                    axisLabel: {
                        formatter: `{value} ${powerUnitText}`
                    }
                },
                series: [
                    {
                        name: predictionErrorText,
                        type: 'line',
                        data: errors,
                        smooth: true,
                        itemStyle: {
                            // 根据误差正负显示不同颜色
                            color: function (params) {
                                if (params.value == null) return '#ddd';
                                return params.value >= 0 ? '#5470c6' : '#c23531';
                            }
                        },
                        markPoint: {
                            data: errors
                                .map((error, idx) => {
                                    if (error != null && Math.abs(error) > errorThreshold) {
                                        return {
                                            coord: [timestamps[idx], error],
                                            value: error.toFixed(2),
                                            itemStyle: {
                                                color: error > 0 ? '#5470c6' : '#c23531'
                                            }
                                        };
                                    }
                                    return null;
                                })
                                .filter(Boolean) // 过滤掉null值
                        },
                        markArea: {
                            itemStyle: {
                                color: 'rgba(255, 173, 177, 0.2)'
                            },
                            data: [
                                [
                                    { 
                                        yAxis: errorThreshold, 
                                        xAxis: timestamps[0],
                                        name: currentLang === 'zh' ? '超出阈值(正)' : 'Above Threshold(+)'
                                    },
                                    { 
                                        yAxis: maxAbsError * 1.1, 
                                        xAxis: timestamps[timestamps.length - 1] 
                                    }
                                ],
                                [
                                    { 
                                        yAxis: -maxAbsError * 1.1, 
                                        xAxis: timestamps[0],
                                        name: currentLang === 'zh' ? '超出阈值(负)' : 'Below Threshold(-)'
                                    },
                                    { 
                                        yAxis: -errorThreshold, 
                                        xAxis: timestamps[timestamps.length - 1] 
                                    }
                                ]
                            ]
                        }
                    },
                    {
                        name: `${errorThresholdText} (+)`,
                        type: 'line',
                        data: upperThreshold,
                        lineStyle: {
                            type: 'dashed',
                            color: '#fac858'
                        },
                        symbol: 'none'
                    },
                    {
                        name: `${errorThresholdText} (-)`,
                        type: 'line',
                        data: lowerThreshold,
                        lineStyle: {
                            type: 'dashed',
                            color: '#fac858'
                        },
                        symbol: 'none'
                    }
                ],
                grid: {
                    left: '5%',
                    right: '5%',
                    bottom: '10%',
                    containLabel: true
                }
            }, true);
            
            console.log('误差图表更新完成');
        } catch (error) {
            console.error('更新误差图表失败:', error);
        }
    }

    // 页面卸载时清理定时器
    window.addEventListener('beforeunload', function () {
        console.log('页面卸载，清理资源...');
        stopRealTimeUpdates();
    });

    // 窗口大小变化时重新调整图表大小
    window.addEventListener('resize', function () {
        // 添加延迟以确保DOM元素尺寸已经稳定
        setTimeout(() => {
            console.log('窗口大小变化，调整图表尺寸');
            try {
                if (anomalyChart) anomalyChart.resize();
                if (errorChart) errorChart.resize();
                if (comparisonChart) comparisonChart.resize();
            } catch (e) {
                console.error('调整图表大小时出错:', e);
            }
        }, 200);
    });

    // 页面可见性变化时的处理
    document.addEventListener('visibilitychange', function () {
        if (document.hidden) {
            // 页面隐藏时暂停更新以节省资源
            console.log('页面隐藏，暂停更新');
        } else {
            // 页面重新可见时恢复更新并立即刷新一次
            console.log('页面重新可见，刷新数据');
            if (document.getElementById('real-time-update').checked) {
                isRealTimeUpdateEnabled = true;
                loadAndUpdateCharts(true);
            }
        }
    });
</script>
{% endblock %}